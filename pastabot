#!/usr/bin/ruby
# frozen_string_literal: true

require 'websocket-client-simple'
require 'rest-client'
require 'logger'
require 'json'

module WebSocket
  module Client
    module Simple
      class Client
        attr_reader :thread
      end
    end
  end
end

class PastaBot
  module Opcode
    DISPATCH = 0
    HEARTBEAT = 1
    IDENTIFY = 2
    RESUME = 6
    RECONNECT = 7
    INVALID_SESSION = 9
    HELLO = 10
  end

  InvalidTokenError = Class.new(StandardError)

  def initialize(token, logger, prefix)
    raise InvalidTokenError.new('Invalid token') if token_invalid?

    @token = token
    @logger = logger
    @prefix = prefix

    @resource = RestClient::Resource.new(
      'https://discord.com/api/v9',
      headers: {
        authorization: @token,
        content_type: 'application/json',
        user_agent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36'
      }
    )

    @file = File.expand_path('~/.pastas.json')
    File.write(@file, '{}') unless File.exist?(@file)
    @pastas = JSON.parse(File.read(@file))
  end

  def run
    loop { connect }
  rescue Interrupt
  ensure
    @ws.close
  end

  def connect
    @ws = WebSocket::Client::Simple.connect('wss://gateway.discord.gg/?v=9&encoding=json')

    @ws.on(:message, &method(:handle_message))
    @ws.on(:open) { @logger.info('Connected') }
    @ws.on(:close, &method(:handle_close))

    @ws.thread.join
  end

  private

  def handle_message(msg)
    @payload = JSON.parse(msg.data)
    @data = @payload['d']

    case @payload['op']
    when Opcode::DISPATCH then handle_dispatch
    when Opcode::RECONNECT, Opcode::INVALID_SESSION then reconnect
    when Opcode::HELLO then handle_hello
    end
  end

  def handle_close(_e)
    @logger.warn('Disconnected')
    @heartbeat&.kill
  end

  def handle_dispatch
    @seq = @payload['s']

    case @payload['t']
    when 'READY' then handle_ready
    when 'MESSAGE_CREATE' then handle_message_create
    end
  end

  def handle_hello
    @logger.debug('Received hello payload')
    setup_heartbeat
    send_identify
  end

  def reconnect
    @logger.warn('Reconnecting...')
    @ws.close
  end

  def handle_ready
    @logger.info('Successfully logged in')
    
    user = @data['user']
    @user_id = user['id']
    @max_msg_size = user['premium_type'] == 2 ? 4000 : 2000
  end

  def handle_message_create
    return if @data['author']['id'] != @user_id

    msg = @data['content']

    return unless msg.start_with?(@prefix)

    cmd, name, pasta = msg.delete_prefix(@prefix).split(' ', 3)
    handle_commands(cmd, name, pasta)
  end

  def handle_commands(cmd, name, pasta)
    case cmd
    when 'a' then add_pasta(name, pasta)
    when 'rm' then remove_pasta(name)
    when 's' then send_pasta(name)
    when 'ls' then pasta_list
    end
  end

  def add_pasta(name, pasta)
    unless name && pasta
      reply('a: The name of the pasta and the pasta itself cannot be empty')
      return
    end

    @pastas[name] = pasta
    File.write(@file, @pastas.to_json)
    delete
  end

  def remove_pasta(name)
    return unless pasta_exists?('rm', name)

    @pastas.delete(name)
    delete
  end

  def send_pasta(name)
    return unless pasta_exists?('s', name)

    reply(@pastas[name])
  end

  def pasta_exists?(cmd, name)
    unless @pastas.key?(name)
      reply("#{cmd}: There is no such pasta")
      return false
    end
    true
  end

  def pasta_list
    msg = @pastas.keys.join(',')

    if msg.size > @max_msg_size
      reply('ls: The message is too long, it will be displayed in the terminal')
      puts msg
    end

    reply(msg)
  end

  def send(msg)
    @ws.send(msg.to_json)
  end

  def send_heartbeat
    send('op' => Opcode::HEARTBEAT, 'd' => @seq)
    @logger.debug('Sent heartbeat payload')
  end

  def setup_heartbeat
    @interval = @data['heartbeat_interval'] / 1000.0
    @heartbeat = Thread.new do
      loop do
        send_heartbeat
        sleep(@interval)
      end
    end
    @logger.debug('Created heartbeat thread')
  end

  def send_identify
    send(
      op: Opcode::IDENTIFY,
      d: {
        token: @token,
        properties: { '$os' => 'linux' },
        intents: 1 << 9 | 1 << 12 | 1 << 15
      }
    )
    @logger.debug('Sent identify payload')
  end

  def message
    @resource["/channels/#{@data['channel_id']}/messages/#{@data['id']}"]
  end

  def reply(content)
    message.patch({ content: content }.to_json)
  end

  def delete
    message.delete
  end

  def token_invalid?
    @resource["/users/@me"].code == 401
  end
end

logger = Logger.new($stdout)
logger.level = Logger::INFO

bot = PastaBot.new(
  ENV['TOKEN'],
  logger,
  'p!'
)

bot.run
